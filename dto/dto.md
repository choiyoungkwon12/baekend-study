# DTO (Data Transfer Object)

F/E 는 사용자의 입력을 받아 B/E에 요청하고, B/E는 요청을 처리해 응답한다.

이 응답을 F/E는 사용자에게 적절한 형태로 보여주고, 사용자는 다시 다른 원하는 행동을 하게 됨.

- 이때, 백엔드와 프론트가 통신할때 JSON이라는 포맷을 활요하며, 자바에서는 DTO라는 형태로 사용한다.

[마틴파울러 - DTO](https://martinfowler.com/eaaCatalog/dataTransferObject.html)
- 엔터프라이즈 어플리케이션 아키텍쳐 패턴 책의 일부

DTO 란 (Data Transfer Object)
- An object that carries data between processes in order to reduce the number of method calls.
    - 메서드 호출 횟수를 줄이기 위해 프로세스 간에 데이터를 전달하는 개체
- When you're working with a remote interface, such as Remote Facade (388), each call to it is expensive.
    - Remote Facade(388)와 같은 원격 인터페이스로 작업할 때 호출할 때마다 비용이 많이 듭니다.

- 여기서 말하는 서로 다른 프로세스는 `IPC, Inter-Process Communication (프로세스 간 통신)` 이라고 한다.
  - 좀 더 강하게 이야기하면, 서로 다른 프로그램이 통신하는 것인데, B/E, F/E로 티어를 나누면 IPC가 필수임.
  - IPC에서 사용할 수 있는 기술
    - FILE - 기본적인 접근 방법이지만, 원격에서는 활용하기 어려움.
    - Socket -> 파일과 유사하게 읽고 쓸 수 있지만, 원격 환경에서도 활용 가능
      - HTTP 같은 고수준 프로토콜을 활용하면 어느 정도 틀이 있어서 상대적으로 쉬워짐
      - `REST를 활용 하면 RPC(SOAP의 일반적인 활용)가 아닌 Resource에 대한 CRUD로 정리`
    - JAVA에서는 RPC를 위해 RMI(Remote Method Invocation)란 기술을 제공
      - RPC : https://ko.wikipedia.org/wiki/%EC%9B%90%EA%B2%A9_%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80_%ED%98%B8%EC%B6%9C
      - RMI : Java Remote Method Invocation, Java RMI (자바 프로그램에서 각 객체간, 컴퓨터간 메서드를 호출할 수 있게 해주는 기술이다.) 

REST에선 표현을 다뤄야 하고, 이를 위해 데이터를 담는 것 외엔 사실상 아무 것도 하지 않아서 제대로 된 객체라고 볼 수 없는 (하지만 Java에선 어쩔 수 없이 class를 활용해서 쓸 수 밖에 없는) 특별한 객체를 사용하게 된다.
- ['무기력한 도메인 모델' 안티패턴](https://martinfowler.com/bliki/AnemicDomainModel.html)

DTO
- 단순하게 보면 setter, getter로 이루어짐.
- 자바빈즈에서 유래한 자바빈 또는 빈이락 부르는 형태에 가까움(Spring Bean, POJO와 다름!)
- 단순한 데이터 운반용으로 사용됨.

### Tier 간 통신
- FE, BE 사이 통신 시 사용됨.
  - DTO 자체로의 전송은 할 수 없고, 직렬화(마샬링)을 통해야 한다.
  - 어떤 직렬화 기술을 사용할 건지도 결정해야 함. -> XML, JSON이 있음.
- JPA를 지양하고 DDD를 따르는 사람 중 일부는 ORM(JPA, 하이버네이트)는 Active Record + DTO 정도만 사용한다고 함.
  - Active Record란 DB의 테이블과 객체를 1:1로 매핑 시켜 놓고, CRUD 작업을 수행하는 메서드를 제공하며, 각 인스턴스는 자신이 표현하는 테이블의 데이터를 저장.
    - 객체와 db 테이블 간의 매핑을 간단하게 처리할 수 있으나, 도메인 모델과 데이터베이스 스키마가 결합되어 있어서 유지보수 하는데 좀 더 어려울 수 있고, 객체의 역할과 책임이 모호해 질 수 있음.

`DDD를 따를 때 JPA를 지양하는 이유?`
- 복잡한 도메인 모델
    - DDD는 도메인 모델을 중심으로 설계되며, 도메인의 복잡성을 다루는 데 중점을 둡니다. 
    - JPA는 객체-관계 매핑을 위한 기술로, 데이터베이스 스키마를 중심으로 데이터 모델을 설계합니다. 따라서, DDD에서는 JPA를 사용하여 도메인 모델을 설계하면 복잡성이 증가할 수 있습니다.

- 도메인 모델의 순수성 유지
    - DDD에서는 도메인 모델을 순수한 객체로 유지하는 것이 중요합니다. 
    - 이는 도메인 객체가 비즈니스 로직에만 집중하고 데이터베이스나 인프라스트럭처와의 상호작용을 최소화하기 위함입니다. 
    - JPA는 객체-관계 매핑을 위한 기술로, 데이터베이스와의 상호작용을 필요로 합니다. 이로 인해 도메인 모델의 순수성이 저하될 수 있습니다.

- 복잡한 쿼리 및 성능 문제
    - JPA는 복잡한 쿼리 및 성능 문제를 해결하기 위한 다양한 기능을 제공합니다. 
    - 그러나 DDD에서는 도메인 모델과 비즈니스 로직에 초점을 맞추므로, JPA의 이러한 기능을 사용하면 도메인 모델과의 결합도가 증가하고, 코드가 복잡해질 수 있습니다.
  
- DDD에서는 JPA보다는 순수한 객체를 사용하여 도메인 모델을 구현하는 것이 좋습니다. 이를 통해 도메인 모델의 복잡성을 줄이고, 도메인 모델의 순수성을 유지하며, 높은 유연성과 확장성을 보장할 수 있습니다.

---

### Remote Facade란?
 - Enterprise Application Architecture Patterns 책에서 설명하는 아키텍처 패턴 중 하나로 클라이언트와 서버 간의 통신을 관리하기 위해 사용됨.
 - 분산 시스템에서 서버측의 비즈니스 로직을 직접 호출하는 것은 좋지 않기 때문에, Remote Facade 패턴은 서버측에서 비즈니스 로직을 실행하고 결과를 반환하는 퍼사드를 만들고 쿨러아언트는 퍼사드를 호출함으로 서버와 통신함.
 - 장점으로 서버의 비즈니스 로직과 클라이언트의 인터페이스를 분리하여, 서로간의 의존성을 줄일 수 있음.
 - 또, 서버측에서 성능과 보안의 최적화 할 수 있는 유연성을 가지게 됨.
 - Remote Facade 패턴은 서버 측의 복잡성을 추상화하고, 클라이언트 측에서 비즈니스 로직을 호출하는 것을 쉽게 만들어줍니다. 이 패턴은 RMI(Remote Method Invocation), CORBA(Common Object Request Broker Architecture), Web Services 등 다양한 분산 기술에서 사용될 수 있습니다.

무조건 퍼사드 패턴을 적용 해야하는것은 아니며, 시스템의 유지보수성, 확장성, 재사용성을 개선할 수 있지만, 반드시 필요한 경우에만 적용하는 것이 좋음.

- `퍼사드 패턴을 사용하는 경우`
  - 복잡한 시스템 구조를 가진 경우 : 시스템이 복잡하고, 다양한 구성 요소를 가진 경우, 각 구성요소 간 의존성이 높아지는 문제가 발생할 수 있는데 이 경우, 퍼사드 패턴을 사용하면 구성 요소 사이의 인터페이스를 추상화하고 의존성을 낮출 수 있음.
  - 서브 시스템 단위로 나누어져 있는 대규모 시스템인 경우 : 대규모 시스템에서 특정 서브시스템을 분리하여 독립적으로 관리하고, 다른 시스템과 상호작용할 필요가 있는 경우, 퍼사드 패턴을 사용하여 서브시스템 간의 인터페이스를 추상화할 수 있습니다.
  - 기능 확장성: 시스템이 새로운 기능을 추가하거나 기존 기능을 변경할 필요가 있는 경우, 퍼사드 패턴을 사용하여 기존 구성 요소를 수정하지 않고, 새로운 기능을 추가하거나 변경할 수 있습니다.

- `퍼사드 패턴을 지양해야 하는 경우`
  - 단순한 시스템 구조: 시스템이 단순하고 구성 요소 간의 의존성이 낮은 경우, 퍼사드 패턴을 적용하는 것은 비효율적일 수 있습니다. 
  - 성능 이슈: 시스템이 대량의 데이터를 처리하거나 높은 처리 속도가 요구되는 경우, 퍼사드 패턴을 적용하면 성능에 영향을 미칠 수 있습니다. 이 경우, 직접적인 호출 방식을 사용하는 것이 더 적절할 수 있습니다. 
  - 유연성 보다 안정성 우선: 시스템이 안정성이 중요한 경우, 퍼사드 패턴을 적용하여 시스템의 유연성을 높일 수 있지만, 이에 따른 안정성 문제가 발생할 수 있습니다. 이 경우, 유연성을 포기하고 안정성을 우선시하는 것이 더 적절할 수 있습니다.
